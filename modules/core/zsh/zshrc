#!/bin/zsh
# =====================================================
# 🚀 ZSH Configuration - Arch Dream v4.3 OPTIMIZED
# =====================================================
# Focused and essential Zsh configuration with performance optimizations
# =====================================================

# =====================================================
# 📚 HISTORIAL OPTIMIZADO
# =====================================================

HISTFILE=~/.zsh_history
HISTSIZE=50000
SAVEHIST=50000

# Opciones de historial esenciales
setopt HIST_IGNORE_DUPS          # No duplicar comandos consecutivos
setopt HIST_IGNORE_ALL_DUPS      # Eliminar duplicados en todo el historial
setopt HIST_SAVE_NO_DUPS         # No guardar duplicados
setopt HIST_FIND_NO_DUPS         # No mostrar duplicados en búsqueda
setopt HIST_IGNORE_SPACE         # Ignorar comandos que empiecen con espacio
setopt HIST_REDUCE_BLANKS        # Eliminar espacios extras
setopt HIST_VERIFY               # Verificar antes de ejecutar !!
setopt SHARE_HISTORY             # Compartir historial entre sesiones
setopt APPEND_HISTORY            # Agregar al historial
setopt INC_APPEND_HISTORY        # Escribir inmediatamente
setopt EXTENDED_HISTORY          # Incluir timestamps

# Navegación de directorios
setopt AUTO_CD                   # cd automático
setopt AUTO_PUSHD                # push automático al directorio stack
setopt PUSHD_IGNORE_DUPS         # No duplicar en stack

# =====================================================
# ⚡ COMPLETION BÁSICO OPTIMIZADO
# =====================================================

# Cache de completiones para mejor performance
[[ ! -d ~/.zsh/cache ]] && mkdir -p ~/.zsh/cache
autoload -Uz compinit
compinit -d ~/.zsh/cache/.zcompdump

setopt COMPLETE_IN_WORD          # Completar en medio de palabras
setopt ALWAYS_TO_END             # Cursor al final después de completar
setopt AUTO_MENU                 # Mostrar menu de completions
setopt AUTO_LIST                 # Listar opciones automáticamente

# Opciones adicionales útiles
setopt CORRECT                   # Corregir comandos mal escritos
setopt EXTENDED_GLOB             # Globbing extendido
setopt NO_BEEP                   # Sin sonidos

# =====================================================
# 🎨 STARSHIP PROMPT OPTIMIZADO
# =====================================================

# Inicialización directa de Starship con fallback seguro
export STARSHIP_CONFIG="${STARSHIP_CONFIG:-$HOME/.config/starship.toml}"

# Inicialización condicional de Starship
if command -v starship &>/dev/null; then
    # Evitar errores "parameter not set" cuando Starship consulta variables internas
    export STARSHIP_CMD_STATUS="${STARSHIP_CMD_STATUS-0}"
    export STARSHIP_DURATION="${STARSHIP_DURATION-0}"
    
    # Hook para establecer estado del comando antes de cada prompt
    starship_precmd() {
        export STARSHIP_CMD_STATUS=$?
    }
    
    # Agregar el hook a las funciones precmd
    precmd_functions+=(starship_precmd)
    
    # Inicializar Starship
    eval "$(starship init zsh)"
else
    # Prompt personalizado optimizado como fallback
    setopt PROMPT_SUBST
    precmd_functions+=(custom_prompt)
fi

# =====================================================
# 🔧 VARIABLES DE ENTORNO OPTIMIZADAS
# =====================================================

export EDITOR='nvim'
export VISUAL='nvim'
export BROWSER='firefox'
export TERMINAL='kitty'
export LANG='en_US.UTF-8'
export LC_ALL='en_US.UTF-8'
# Asegurar que LS_COLORS exista antes de usarlo en estilos de completion
export LS_COLORS="${LS_COLORS-}"

# =====================================================
# 📂 ALIASES ESENCIALES OPTIMIZADOS
# =====================================================

# Navegación
alias ..='cd ..'
alias ...='cd ../..'
alias ....='cd ../../..'
alias -- -='cd -'

# Operaciones de archivos
alias cp='cp -iv'
alias mv='mv -iv'
alias rm='rm -I'
alias mkdir='mkdir -pv'

# Listado de archivos con fallback inteligente
if command -v eza &>/dev/null; then
    alias ls='eza --icons --group-directories-first'
    alias ll='eza -l --icons --group-directories-first'
    alias la='eza -la --icons --group-directories-first'
    alias tree='eza --tree --icons'
elif command -v exa &>/dev/null; then
    alias ls='exa --icons --group-directories-first'
    alias ll='exa -l --icons --group-directories-first'
    alias la='exa -la --icons --group-directories-first'
    alias tree='exa --tree --icons'
else
    alias ll='ls -l --color=auto'
    alias la='ls -la --color=auto'
fi

# Herramientas modernas con fallback
if command -v bat &>/dev/null; then
    alias cat='bat --style=auto --paging=never'
fi

if command -v btop &>/dev/null; then
    alias htop='btop'
    alias top='btop'
elif command -v htop &>/dev/null; then
    alias top='htop'
fi

if command -v rg &>/dev/null; then
    alias grep='rg --smart-case --hidden'
fi

if command -v fd &>/dev/null; then
    alias find='fd --hidden --follow'
fi

# Git shortcuts optimizados
alias g='git'
alias gs='git status -sb'
alias ga='git add'
alias gc='git commit'
alias gp='git push'
alias gl='git pull'
alias gd='git diff'
alias gco='git checkout'
alias gb='git branch'
alias glog='git log --oneline --graph --decorate --max-count=20'

# Sistema optimizado
alias myip='curl -s --max-time 5 ipinfo.io/ip'
alias ports='ss -tulanp'
alias sysinfo='fastfetch 2>/dev/null || neofetch 2>/dev/null || uname -a'

# Arch Linux optimizado
alias pacupdate='sudo pacman -Syu'
alias pacinstall='sudo pacman -S'
alias pacsearch='pacman -Ss'
alias aurinstall='yay -S'
alias aurupdate='yay -Syu'

# =====================================================
# 🔌 PLUGINS OPTIMIZADOS - Lazy Loading
# =====================================================

# Función para lazy loading de plugins
load_plugin() {
    local plugin_path="$1"
    local plugin_name="$2"
    
    if [[ -f "$plugin_path" ]]; then
        source "$plugin_path"
        # echo "✅ Plugin cargado: $plugin_name"
    fi
}

# Autosuggestions - Solo cargar cuando se necesite
if [[ -f /usr/share/zsh/plugins/zsh-autosuggestions/zsh-autosuggestions.zsh ]]; then
    load_plugin "/usr/share/zsh/plugins/zsh-autosuggestions/zsh-autosuggestions.zsh" "autosuggestions"
    ZSH_AUTOSUGGEST_HIGHLIGHT_STYLE='fg=240'
    ZSH_AUTOSUGGEST_STRATEGY=(history completion)
    ZSH_AUTOSUGGEST_BUFFER_MAX_SIZE=20
    ZSH_AUTOSUGGEST_USE_ASYNC=true
fi

# Syntax highlighting - Cargar al final
if [[ -f /usr/share/zsh/plugins/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh ]]; then
    load_plugin "/usr/share/zsh/plugins/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh" "syntax-highlighting"
fi

# Completions adicionales
if [[ -d /usr/share/zsh/plugins/zsh-completions ]]; then
    fpath=(/usr/share/zsh/plugins/zsh-completions/src $fpath)
fi

# FZF - Solo cargar si está disponible
if command -v fzf &>/dev/null; then
    # Configuración optimizada de FZF
    export FZF_DEFAULT_OPTS="--height 50% --layout=reverse --border --preview-window=right:60%"
    
    # Configurar comandos de búsqueda
    if command -v fd &>/dev/null; then
        export FZF_DEFAULT_COMMAND='fd --type f --hidden --follow --exclude .git'
        export FZF_CTRL_T_COMMAND="$FZF_DEFAULT_COMMAND"
    fi
    
    # Cargar key bindings y completion
    source /usr/share/fzf/key-bindings.zsh 2>/dev/null
    source /usr/share/fzf/completion.zsh 2>/dev/null
fi

# Zoxide - Mejor cd
if command -v zoxide &>/dev/null; then
    eval "$(zoxide init zsh)"
    alias cd='z'
fi

# Atuin - Historial mejorado
if command -v atuin &>/dev/null; then
    eval "$(atuin init zsh)"
fi

# =====================================================
# 🎯 KEY BINDINGS OPTIMIZADOS
# =====================================================

bindkey -e  # Emacs-style

# History search optimizado
bindkey '^R' history-incremental-search-backward
bindkey '^P' history-search-backward
bindkey '^N' history-search-forward

# Navegación mejorada
bindkey '^[[1;5C' forward-word      # Ctrl+Right
bindkey '^[[1;5D' backward-word     # Ctrl+Left
bindkey '^H' backward-kill-word     # Ctrl+Backspace
bindkey '^[[3;5~' kill-word         # Ctrl+Delete

# =====================================================
# 🎨 WELCOME MESSAGE OPTIMIZADO
# =====================================================

# Solo mostrar welcome message una vez por sesión
if [[ -z "$FASTFETCH_SHOWN" && -z "${TMUX:-}${STY:-}" ]]; then
    if command -v fastfetch &>/dev/null; then
        fastfetch --config ~/.config/fastfetch/config.jsonc 2>/dev/null || fastfetch
        export FASTFETCH_SHOWN=1
    elif command -v neofetch &>/dev/null; then
        neofetch
        export FASTFETCH_SHOWN=1
    fi
fi

# =====================================================
# 🔧 FUNCIONES ÚTILES OPTIMIZADAS
# =====================================================

# Crear directorio y entrar
mkcd() {
    mkdir -p "$1" && cd "$1"
}

# Extraer archivos optimizado
extract() {
    if [[ -f $1 ]]; then
        case $1 in
            *.tar.bz2)   tar xjf "$1"    ;;
            *.tar.gz)    tar xzf "$1"    ;;
            *.bz2)       bunzip2 "$1"   ;;
            *.rar)       unrar x "$1"   ;;
            *.gz)        gunzip "$1"    ;;
            *.tar)       tar xf "$1"    ;;
            *.tbz2)      tar xjf "$1"   ;;
            *.tgz)       tar xzf "$1"   ;;
            *.zip)       unzip "$1"     ;;
            *.Z)         uncompress "$1";;
            *.7z)        7z x "$1"      ;;
            *)           echo "'$1' no se puede extraer" ;;
        esac
    else
        echo "'$1' no es un archivo válido"
    fi
}

# Backup con timestamp optimizado
backup() {
    local filename="$1"
    local backup_name="${filename}.backup.$(date +%Y%m%d_%H%M%S)"
    cp "$filename" "$backup_name"
    echo "✅ Backup creado: $backup_name"
}

# Recargar configuración
reload() {
    source ~/.zshrc
    echo "✅ Configuración de Zsh recargada"
}

# Información del sistema optimizada
quickinfo() {
    echo -e "\033[1;34mSistema:\033[0m $(uname -sr)"
    echo -e "\033[1;34mHostname:\033[0m $(hostname)"
    echo -e "\033[1;34mUptime:\033[0m $(uptime -p 2>/dev/null || uptime)"
    echo -e "\033[1;34mUsuario:\033[0m $(whoami)"
    echo -e "\033[1;34mShell:\033[0m $SHELL"
}

# Actualizar Arch optimizado
function arch-update() {
    echo "🔄 Actualizando sistema..."
    sudo pacman -Syu && {
        echo "✅ Sistema actualizado"
        if command -v yay &>/dev/null; then
            echo "🔄 Actualizando AUR..."
            yay -Syu --noconfirm
        fi
    }
}

# Buscar paquetes optimizado
arch-search() {
    [[ -z "$1" ]] && { echo "Uso: arch-search <paquete>"; return 1; }
    echo "🔍 Búsqueda en repositorios oficiales:"
    pacman -Ss "$1"
    if command -v yay &>/dev/null; then
        echo "🔍 Búsqueda en AUR:"
        yay -Ss "$1"
    fi
}

# =====================================================
# 📋 CUSTOMIZACIONES LOCALES
# =====================================================

[[ -f ~/.zshrc.local ]] && source ~/.zshrc.local

# =====================================================
# 🎨 COMPLETION STYLING OPTIMIZADO
# =====================================================

zstyle ':completion:*' menu select
zstyle ':completion:*' list-colors "${(s.:.)LS_COLORS}"
zstyle ':completion:*' matcher-list 'm:{a-zA-Z}={A-Za-z}'
zstyle ':completion:*' accept-exact '*(N)'
zstyle ':completion:*' use-cache on
zstyle ':completion:*' cache-path ~/.zsh/cache

# =====================================================
# ⚡ LAZY LOADING OPTIMIZADO
# =====================================================

# NVM lazy loading mejorado
if [[ -d "$HOME/.nvm" ]]; then
    export NVM_DIR="$HOME/.nvm"
    export NVM_LAZY_LOAD=true
    
    nvm() {
        unset -f nvm
        [ -s "$NVM_DIR/nvm.sh" ] && \. "$NVM_DIR/nvm.sh"
        nvm "$@"
    }
    
    node() {
        unset -f node
        [ -s "$NVM_DIR/nvm.sh" ] && \. "$NVM_DIR/nvm.sh"
        node "$@"
    }
    
    npm() {
        unset -f npm
        [ -s "$NVM_DIR/nvm.sh" ] && \. "$NVM_DIR/nvm.sh"
        npm "$@"
    }
fi

# =====================================================
# 🎨 PROMPT PERSONALIZADO OPTIMIZADO
# =====================================================

# Prompt personalizado para cuando Starship no esté disponible
custom_prompt() {
    local exit_code=$?
    local user_color="%F{cyan}"
    local host_color="%F{green}"
    local dir_color="%F{blue}"
    local git_color="%F{yellow}"
    
    # Usuario y host
    local prompt_user="$user_color%n@%m%f"
    
    # Directorio actual
    local prompt_dir="$dir_color%~%f"
    
    # Estado de Git (solo si estamos en un repo)
    local git_status=""
    if git rev-parse --is-inside-work-tree &>/dev/null; then
        local branch=$(git branch --show-current 2>/dev/null)
        local status=$(git status --porcelain 2>/dev/null | wc -l)
        if [[ $status -gt 0 ]]; then
            git_status="$git_color[$branch*]%f"
        else
            git_status="$git_color[$branch]%f"
        fi
    fi
    
    # Indicador de exit code
    local exit_indicator=""
    if [[ $exit_code -ne 0 ]]; then
        exit_indicator="%F{red}❯%f"
    else
        exit_indicator="%F{green}❯%f"
    fi
    
    # Variables de contexto Red Team
    local context_info=""
    [[ -n "$TARGET" ]] && context_info="$context_info %F{red}🎯$TARGET%f"
    [[ -n "$PROXY" ]] && context_info="$context_info %F{cyan}🔒$PROXY%f"
    
    PROMPT="$prompt_user:$prompt_dir$git_status$context_info $exit_indicator "
}

# =====================================================
# 🔒 SEGURIDAD Y PRIVACIDAD
# =====================================================

# Variables sensibles (no se guardan en historial)
export API_KEY="" 2>/dev/null
export SECRET_TOKEN="" 2>/dev/null
export DATABASE_PASSWORD="" 2>/dev/null

# =====================================================
# 📊 ALIASES AVANZADOS OPTIMIZADOS
# =====================================================

# Información del sistema
alias status="system_status"
alias context="echo -e \"🎯 Target: ${TARGET:-'No configurado'}\n🔒 Proxy: ${PROXY:-'No configurado'}\""
alias clean="clear-context"

# Herramientas de pentesting (si están disponibles)
command -v nmap &>/dev/null && alias nmap-priv="sudo nmap"
command -v msfconsole &>/dev/null && alias msf="msfconsole"
command -v burpsuite &>/dev/null && alias burp="burpsuite"

# =====================================================
# 🚀 OPTIMIZACIONES FINALES
# =====================================================

# Profiling opcional (descomenta para debugging)
# zmodload zsh/zprof

# Configuración de PATH optimizada
export PATH="$PATH:/home/dreamcoder08/.local/bin"

# Fastfetch aliases optimizados
alias ff="fastfetch"
alias ff-dream="fastfetch --config ~/.config/fastfetch/config.jsonc"
alias ff-custom="fastfetch --config ~/.config/fastfetch/config.local.jsonc"

# Nano aliases optimizados
alias nano="nano --rcfile ~/.config/nano/nanorc"
alias nano-code="nano --rcfile ~/.config/nano/code.nanorc"
alias nano-config="nano --rcfile ~/.config/nano/config.nanorc"
alias nano-log="nano --rcfile ~/.config/nano/log.nanorc"
alias nano-edit="nano --rcfile ~/.config/nano/nanorc.local"

# =====================================================
# 🎯 FUNCIONES AVANZADAS PARA RED TEAM OPTIMIZADAS
# =====================================================

# Función para cambiar contexto de pentesting
pentest-context() {
    local target="$1"
    local proxy="$2"
    
    if [[ -n "$target" ]]; then
        export TARGET="$target"
        echo "🎯 Target configurado: $TARGET"
    fi
    
    if [[ -n "$proxy" ]]; then
        export PROXY="$proxy"
        echo "🔒 Proxy configurado: $PROXY"
    fi
    
    # Actualizar prompt si Starship está disponible
    if command -v starship &>/dev/null && typeset -f starship_precmd > /dev/null; then
        starship_precmd
    fi
}

# Función para limpiar contexto
clear-context() {
    unset TARGET PROXY VPN_STATUS CURRENT_TOOL
    echo "🧹 Contexto limpiado"
    if command -v starship &>/dev/null && typeset -f starship_precmd > /dev/null; then
        starship_precmd
    fi
}

# Función para mostrar información del sistema optimizada
system_status() {
    local cpu_usage=$(top -bn1 2>/dev/null | grep "Cpu(s)" | awk '{print $2}' | cut -d'%' -f1 || echo "N/A")
    local mem_usage=$(free 2>/dev/null | grep Mem | awk '{printf("%.1f", $3/$2 * 100.0)}' || echo "N/A")
    local disk_usage=$(df / 2>/dev/null | tail -1 | awk '{print $5}' | sed 's/%//' || echo "N/A")
    
    echo -e "💻 CPU: ${cpu_usage}% | 🧠 RAM: ${mem_usage}% | 💾 DISK: ${disk_usage}%"
}

# Función para limpiar historial sensible
clean_history() {
    local sensitive_patterns=("password" "token" "key" "secret" "passwd" "api_key")
    for pattern in "${sensitive_patterns[@]}"; do
        sed -i "/$pattern/d" ~/.zsh_history 2>/dev/null
    done
    echo "🧹 Historial sensible limpiado"
}

# =====================================================
# ✅ INICIALIZACIÓN COMPLETADA
# =====================================================

# Mensaje de confirmación
echo "🚀 ZSH optimizado cargado exitosamente!"
