#!/bin/bash
# =====================================================
# üîÑ ARCH DREAM - SISTEMA DE AUTO-ACTUALIZACI√ìN
# =====================================================
# Sistema inteligente de actualizaci√≥n autom√°tica
# Mantiene el proyecto optimizado y actualizado
# =====================================================

set -euo pipefail
IFS=$'\n\t'

# =====================================================
# üîß CONFIGURACI√ìN
# =====================================================

# Directorios y archivos
UPDATE_ROOT="${XDG_STATE_HOME:-$HOME/.local/state}/arch-dream/updates"
UPDATE_LOG="$UPDATE_ROOT/update.log"
UPDATE_CONFIG="$UPDATE_ROOT/config.json"
LAST_CHECK_FILE="$UPDATE_ROOT/last_check"

# Configuraci√≥n por defecto
DEFAULT_UPDATE_INTERVAL=86400  # 24 horas
DEFAULT_AUTO_UPDATE=false
DEFAULT_BACKUP_BEFORE_UPDATE=true
DEFAULT_NOTIFICATION_ENABLED=true

# URLs y versiones
GITHUB_REPO="Albert-fer02/arch-dream"
CURRENT_VERSION="4.0.0"
VERSION_CHECK_URL="https://api.github.com/repos/$GITHUB_REPO/releases/latest"

# =====================================================
# üîß INICIALIZACI√ìN
# =====================================================

init_auto_updater() {
    debug "Inicializando sistema de auto-actualizaci√≥n..."
    
    mkdir -p "$UPDATE_ROOT"
    chmod 755 "$UPDATE_ROOT"
    
    # Crear configuraci√≥n por defecto si no existe
    if [[ ! -f "$UPDATE_CONFIG" ]]; then
        create_default_config
    fi
    
    # Crear log si no existe
    [[ -f "$UPDATE_LOG" ]] || echo "# Arch Dream Auto-Update Log" > "$UPDATE_LOG"
    
    success "‚úÖ Sistema de auto-actualizaci√≥n inicializado"
}

create_default_config() {
    cat > "$UPDATE_CONFIG" << EOF
{
  "auto_update": $DEFAULT_AUTO_UPDATE,
  "update_interval": $DEFAULT_UPDATE_INTERVAL,
  "backup_before_update": $DEFAULT_BACKUP_BEFORE_UPDATE,
  "notification_enabled": $DEFAULT_NOTIFICATION_ENABLED,
  "current_version": "$CURRENT_VERSION",
  "last_update": "",
  "update_branch": "main"
}
EOF
    debug "Configuraci√≥n de auto-actualizaci√≥n creada"
}

# =====================================================
# üîç VERIFICACI√ìN DE ACTUALIZACIONES
# =====================================================

check_for_updates() {
    log "üîç Verificando actualizaciones disponibles..."
    
    # Verificar conexi√≥n a internet
    if ! ping -c 1 -W 2 github.com &>/dev/null; then
        warn "‚ö†Ô∏è  Sin conexi√≥n a internet, saltando verificaci√≥n"
        return 1
    fi
    
    # Obtener √∫ltima versi√≥n desde GitHub
    local latest_version=""
    if command -v curl &>/dev/null; then
        latest_version=$(curl -s "$VERSION_CHECK_URL" | grep '"tag_name"' | sed -E 's/.*"tag_name": "([^"]+)".*/\1/' 2>/dev/null || echo "")
    elif command -v wget &>/dev/null; then
        latest_version=$(wget -qO- "$VERSION_CHECK_URL" | grep '"tag_name"' | sed -E 's/.*"tag_name": "([^"]+)".*/\1/' 2>/dev/null || echo "")
    fi
    
    if [[ -z "$latest_version" ]]; then
        warn "‚ö†Ô∏è  No se pudo obtener informaci√≥n de la √∫ltima versi√≥n"
        return 1
    fi
    
    # Comparar versiones
    if [[ "$latest_version" != "$CURRENT_VERSION" ]]; then
        log "üÜï Nueva versi√≥n disponible: $latest_version (actual: $CURRENT_VERSION)"
        echo "$latest_version"
        return 0
    else
        debug "Sistema actualizado (versi√≥n: $CURRENT_VERSION)"
        return 1
    fi
}

# =====================================================
# üì• DESCARGA Y APLICACI√ìN
# =====================================================

download_update() {
    local version="$1"
    local download_dir="$UPDATE_ROOT/downloads/$version"
    local archive_url="https://github.com/$GITHUB_REPO/archive/refs/tags/$version.tar.gz"
    
    log "üì• Descargando actualizaci√≥n $version..."
    
    mkdir -p "$download_dir"
    
    # Descargar archivo
    local archive_file="$download_dir/update.tar.gz"
    if command -v curl &>/dev/null; then
        curl -L -o "$archive_file" "$archive_url" || return 1
    elif command -v wget &>/dev/null; then
        wget -O "$archive_file" "$archive_url" || return 1
    else
        error "‚ùå No se encontr√≥ curl o wget para descargar"
        return 1
    fi
    
    # Extraer archivo
    if tar -xzf "$archive_file" -C "$download_dir" --strip-components=1; then
        success "‚úÖ Actualizaci√≥n descargada y extra√≠da"
        echo "$download_dir"
    else
        error "‚ùå Error extrayendo actualizaci√≥n"
        return 1
    fi
}

apply_update() {
    local update_dir="$1"
    local version="$2"
    
    log "üîÑ Aplicando actualizaci√≥n $version..."
    
    # Crear backup antes de actualizar
    if get_config_value "backup_before_update"; then
        create_pre_update_backup "$version"
    fi
    
    # Verificar que los archivos cr√≠ticos existen en la actualizaci√≥n
    local critical_files=(
        "lib/shell-base.sh"
        "lib/module-manager.sh"
        "install-simple.sh"
    )
    
    for file in "${critical_files[@]}"; do
        if [[ ! -f "$update_dir/$file" ]]; then
            error "‚ùå Archivo cr√≠tico faltante en actualizaci√≥n: $file"
            return 1
        fi
    done
    
    # Aplicar actualizaci√≥n
    local project_root="$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd)"
    
    # Copiar archivos nuevos (preservando configuraciones locales)
    rsync -av --exclude="*.local" --exclude="backups/" --exclude=".git/" \
          "$update_dir/" "$project_root/" || {
        error "‚ùå Error aplicando actualizaci√≥n"
        return 1
    }
    
    # Actualizar permisos
    chmod +x "$project_root"/*.sh
    chmod +x "$project_root/lib"/*.sh
    
    # Actualizar versi√≥n en configuraci√≥n
    update_config_value "current_version" "$version"
    update_config_value "last_update" "$(date -Iseconds)"
    
    # Log de actualizaci√≥n
    echo "$(date -Iseconds) | UPDATE | $CURRENT_VERSION -> $version | success" >> "$UPDATE_LOG"
    
    success "‚úÖ Actualizaci√≥n $version aplicada exitosamente"
}

# =====================================================
# üíæ BACKUP PRE-ACTUALIZACI√ìN
# =====================================================

create_pre_update_backup() {
    local version="$1"
    local backup_name="pre_update_${version}_$(date +%Y%m%d_%H%M%S)"
    
    log "üíæ Creando backup pre-actualizaci√≥n..."
    
    # Usar sistema de backup simple si est√° disponible
    if [[ -f "lib/simple-backup.sh" ]]; then
        source "lib/simple-backup.sh"
        simple_backup_main create "$backup_name" "Backup antes de actualizar a $version" &>/dev/null
    else
        # Backup manual b√°sico
        local backup_dir="$UPDATE_ROOT/backups/$backup_name"
        mkdir -p "$backup_dir"
        
        local important_files=(
            "$HOME/.bashrc" "$HOME/.zshrc"
            "$HOME/.config/starship.toml"
            "$HOME/.config/kitty/kitty.conf"
            "$HOME/.config/nvim/init.lua"
        )
        
        for file in "${important_files[@]}"; do
            if [[ -e "$file" ]]; then
                local target_dir="$backup_dir/$(dirname "${file#$HOME/}")"
                mkdir -p "$target_dir"
                cp -r "$file" "$target_dir/"
            fi
        done
    fi
    
    success "‚úÖ Backup pre-actualizaci√≥n creado"
}

# =====================================================
# ‚öôÔ∏è GESTI√ìN DE CONFIGURACI√ìN
# =====================================================

get_config_value() {
    local key="$1"
    
    if [[ -f "$UPDATE_CONFIG" ]] && command -v jq &>/dev/null; then
        jq -r ".$key" "$UPDATE_CONFIG" 2>/dev/null || echo "null"
    else
        # Fallback simple sin jq
        case "$key" in
            auto_update) echo "$DEFAULT_AUTO_UPDATE" ;;
            update_interval) echo "$DEFAULT_UPDATE_INTERVAL" ;;
            backup_before_update) echo "$DEFAULT_BACKUP_BEFORE_UPDATE" ;;
            *) echo "null" ;;
        esac
    fi
}

update_config_value() {
    local key="$1"
    local value="$2"
    
    if [[ -f "$UPDATE_CONFIG" ]] && command -v jq &>/dev/null; then
        local temp_file=$(mktemp)
        jq --arg key "$key" --arg value "$value" '.[$key] = $value' "$UPDATE_CONFIG" > "$temp_file"
        mv "$temp_file" "$UPDATE_CONFIG"
    else
        # Recrear configuraci√≥n b√°sica
        create_default_config
    fi
}

# =====================================================
# üîî NOTIFICACIONES
# =====================================================

send_notification() {
    local title="$1"
    local message="$2"
    local urgency="${3:-normal}"
    
    # Verificar si las notificaciones est√°n habilitadas
    if [[ "$(get_config_value "notification_enabled")" != "true" ]]; then
        return 0
    fi
    
    # Enviar notificaci√≥n si notify-send est√° disponible
    if command -v notify-send &>/dev/null; then
        notify-send -u "$urgency" "$title" "$message"
    else
        # Fallback a echo con colores
        case "$urgency" in
            critical) error "üö® $title: $message" ;;
            normal) log "üîî $title: $message" ;;
            low) debug "‚ÑπÔ∏è $title: $message" ;;
        esac
    fi
}

# =====================================================
# ‚è∞ GESTI√ìN DE INTERVALOS
# =====================================================

should_check_for_updates() {
    local update_interval=$(get_config_value "update_interval")
    
    if [[ ! -f "$LAST_CHECK_FILE" ]]; then
        return 0  # Primera vez, verificar
    fi
    
    local last_check=$(cat "$LAST_CHECK_FILE" 2>/dev/null || echo "0")
    local current_time=$(date +%s)
    local time_diff=$((current_time - last_check))
    
    if [[ $time_diff -gt $update_interval ]]; then
        return 0  # Es hora de verificar
    else
        return 1  # A√∫n no es hora
    fi
}

update_last_check_time() {
    echo "$(date +%s)" > "$LAST_CHECK_FILE"
}

# =====================================================
# üèÅ FUNCIONES PRINCIPALES
# =====================================================

run_update_check() {
    local force="${1:-false}"
    
    # Verificar si debe chequear actualizaciones
    if [[ "$force" != "true" ]] && ! should_check_for_updates; then
        debug "No es hora de verificar actualizaciones"
        return 0
    fi
    
    # Actualizar tiempo de √∫ltima verificaci√≥n
    update_last_check_time
    
    # Verificar actualizaciones
    local latest_version=""
    if latest_version=$(check_for_updates); then
        # Nueva versi√≥n disponible
        send_notification "Arch Dream" "Nueva versi√≥n disponible: $latest_version" "normal"
        
        # Auto-actualizar si est√° habilitado
        if [[ "$(get_config_value "auto_update")" == "true" ]]; then
            run_auto_update "$latest_version"
        else
            log "üí° Para actualizar manualmente: auto_updater_main update"
        fi
    fi
}

run_auto_update() {
    local version="$1"
    
    log "üöÄ Iniciando auto-actualizaci√≥n a $version..."
    
    # Descargar actualizaci√≥n
    local update_dir=""
    if update_dir=$(download_update "$version"); then
        # Aplicar actualizaci√≥n
        if apply_update "$update_dir" "$version"; then
            send_notification "Arch Dream" "Actualizado exitosamente a $version" "normal"
            success "üéâ Sistema actualizado a $version"
        else
            send_notification "Arch Dream" "Error aplicando actualizaci√≥n" "critical"
            error "‚ùå Error aplicando actualizaci√≥n"
        fi
        
        # Limpiar archivos temporales
        rm -rf "$update_dir"
    else
        send_notification "Arch Dream" "Error descargando actualizaci√≥n" "critical"
        error "‚ùå Error descargando actualizaci√≥n"
    fi
}

show_update_status() {
    log "üìä Estado del sistema de actualizaci√≥n..."
    
    echo -e "${BOLD}${BLUE}üìä Estado de Actualizaci√≥n${COLOR_RESET}"
    echo -e "${CYAN}‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê${COLOR_RESET}"
    echo -e "${CYAN}‚îÇ${COLOR_RESET} Versi√≥n actual: $CURRENT_VERSION"
    echo -e "${CYAN}‚îÇ${COLOR_RESET} Auto-actualizaci√≥n: $(get_config_value "auto_update")"
    echo -e "${CYAN}‚îÇ${COLOR_RESET} Intervalo: $(get_config_value "update_interval")s"
    echo -e "${CYAN}‚îÇ${COLOR_RESET} Backup autom√°tico: $(get_config_value "backup_before_update")"
    
    if [[ -f "$LAST_CHECK_FILE" ]]; then
        local last_check=$(cat "$LAST_CHECK_FILE")
        local last_check_date=$(date -d "@$last_check" 2>/dev/null || echo "Desconocido")
        echo -e "${CYAN}‚îÇ${COLOR_RESET} √öltima verificaci√≥n: $last_check_date"
    fi
    
    echo -e "${CYAN}‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò${COLOR_RESET}"
}

# =====================================================
# üèÅ INTERFAZ PRINCIPAL
# =====================================================

auto_updater_main() {
    local action="${1:-help}"
    shift || true
    
    # Inicializar si es necesario
    [[ -d "$UPDATE_ROOT" ]] || init_auto_updater
    
    case "$action" in
        init)
            init_auto_updater
            ;;
        check)
            run_update_check true
            ;;
        update)
            local latest_version=""
            if latest_version=$(check_for_updates); then
                run_auto_update "$latest_version"
            else
                success "‚úÖ Sistema ya est√° actualizado"
            fi
            ;;
        status)
            show_update_status
            ;;
        enable)
            update_config_value "auto_update" "true"
            success "‚úÖ Auto-actualizaci√≥n habilitada"
            ;;
        disable)
            update_config_value "auto_update" "false"
            success "‚úÖ Auto-actualizaci√≥n deshabilitada"
            ;;
        config)
            [[ -f "$UPDATE_CONFIG" ]] && cat "$UPDATE_CONFIG" || echo "No configurado"
            ;;
        help|*)
            cat << 'EOF'
üîÑ Sistema de Auto-Actualizaci√≥n - Arch Dream

Uso: auto_updater_main <acci√≥n> [argumentos]

Acciones:
  init                Inicializar sistema de actualizaci√≥n
  check               Verificar actualizaciones manualmente
  update              Actualizar a la √∫ltima versi√≥n
  status              Mostrar estado del sistema
  enable              Habilitar auto-actualizaci√≥n
  disable             Deshabilitar auto-actualizaci√≥n
  config              Mostrar configuraci√≥n actual
  help                Mostrar esta ayuda

Variables de entorno:
  AUTO_UPDATE_INTERVAL=86400    Intervalo en segundos (default: 24h)
  AUTO_UPDATE_ENABLED=true     Habilitar auto-actualizaci√≥n

Ejemplos:
  auto_updater_main check
  auto_updater_main enable
  auto_updater_main update
EOF
            ;;
    esac
}

# Exportar funciones principales
export -f init_auto_updater check_for_updates run_update_check
export -f run_auto_update show_update_status auto_updater_main

# Variables exportadas
export UPDATE_ROOT UPDATE_LOG UPDATE_CONFIG CURRENT_VERSION